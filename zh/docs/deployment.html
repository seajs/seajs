<!doctype html>
<html>
<head>
<meta http-equiv="pragma" content="no-cache"/>
<meta charset="utf-8"/>
<title>部署 - Sea.js 手册与文档</title>
<link rel="stylesheet" href="../../docs/assets/api.css"/>
</head>
<body>
<div id="container">

  <header>
    <h1>Sea.js 手册与文档</h1>
    <div id="gtoc">
      <p><a href="../">首页</a> | <a href="index.html">索引</a></p>
    </div>
    <hr/>
  </header>

  <div id="toc">
    <h2 id="table_of_Contents">目录</h2>

    <ul>
      <li><a href="#deployment">部署</a>
        <ul>
          <li><a href="#dev-phase">开发阶段</a></li>
          <li><a href="#deploy-phase">部署阶段</a></li>
        </ul>
      </li>
    </ul>
    <hr/>
  </div>


  <h2 id="deployment">部署</h2>

  <p>
    我们看一个例子。
  </p>


  <h3 id="dev-phase">开发阶段</h3>

  <p>
    一个简单的计算器
    <a href="../../docs/demo/calculator/" target="_blank">calculator demo</a>，
    包括以下文件:
  </p>

<pre>
index.html     -- HTML 页面
style.css      -- 样式

init.js        -- 入口脚本
calculator.js  -- 主脚本
stdin.js       -- 输入
stdout.js      -- 输出
math.js        -- 数学类库
</pre>

  <p>
    源代码在
    <a href="https://github.com/seajs/seajs/tree/master/docs/demo/calculator">calculator@github</a>.
  </p>

  <p>
    在 <code>index.html</code> 中，我们使用 <code>script</code> 标签来引导程序。
  </p>

<pre>
&lt;script src="path/to/sea.js" data-main="path/to/init"&gt;&lt;/script&gt;
</pre>

  <p>
    然后所有依赖的脚本都将自动加载。
    <br/>
    <img src="../../docs/demo/calculator/http-requests-dev.png" height="208" width="196"/>
  </p>

  <p>
    在开发阶段，这很舒服。但是显然的，在大型项目中，文件数会迅速增多。如果我们直接将这些文件丢在产品环境，页面的性能将会由于太多 HTTP
 请求而大大降低。这很不好。
  </p>

  <p>
    <strong>如果享受开发时的便利，又仍然能够让产品环境性能卓越?</strong>
  </p>


  <h3 id="deploy-phase">部署阶段</h3>

  <p>
    通过部署阶段时的优化，我们可以得到一个双赢的解决办法。回到计算器项目，我们看看应该怎么做。
  </p>

  <p>
    首先，我们安装 spm 工具:
    <a href="https://github.com/seajs/spm/" target="_blank">spm</a>
  </p>

  <p>
    然后执行以下命令:
  </p>

<pre>
 $ cd path/to/demo/calculator
 $ spm build init.js --combo
   ... process init.js
   ... process stdin.js
   ... process calculator.js
   ... process stdout.js
   ... process math.js
   Successfully combo to __build/init.js
</pre>

  <p>
    我们得到了 <code>init.js</code> 的压缩并合并的版本。
  </p>

<pre>
 $ cat __build/init.js
   seajs.config({alias: {"jquery":"jquery/1.6.2/jquery"}});define("./init"...
   define("./stdin",["jquery","./calculator"],function(a,b){...
   define("./calculator",["./stdout","./math"],function(a,b){...
   define("./stdout",["jquery"],function(a,b){...
   define("./math",[],function(a,b){..
</pre>

  <p>
    最后，把文件丢到线上环境:
  </p>

<pre>
 $ publish
   Successfully push local/calculator/__build/*.js to online/calculator/*.js
</pre>

  <p>
    从而，我们得到了线上版本:
    <a href="../../docs/demo/calculator/online/" target="_blank">在线计算器</a>.
  </p>

  <p>
    我们看看 HTTP 请求数:<br/>
    <img src="../../docs/demo/calculator/http-requests-online.png" height="132" width="192"/>
  </p>

  <p>
    除了 <code>sea.js</code> 和 <code>jquery.js</code>，其他所有脚本都合并到了一个文件
    <code>init.js</code>。这对页面性能很有帮助。
  </p>

  <p>
    我们还可以用 <code>--combo all</code> 选项把所有依赖的模块合并到单个文件:
  </p>

<pre>
 $ cd path/to/demo/calculator
 $ spm build init.js --combo all
   ... process init.js
   ... process stdin.js
   ... process jquery.js
   ... process calculator.js
   ... process stdout.js
   ... process math.js
   Successfully combo to __build/init.js
</pre>

  <p>
    如此，<code>__build/init.js</code> 也会包含
    <code>jquery.js</code>，而对脚本的 HTTP 请求就只剩下一个。
  </p>

  <p>
    我们看看此独立版本:
    <a href="../../docs/demo/calculator/standalone/">独立计算器</a>.
  </p>

  <p>
    注意，更少的 HTTP 请求并不必然保证更好的性能。浏览器的缓存也该在考虑范围内。
    建议根据实际项目情况采用合适的打包策略。
  </p>

  <p>
    更多信息，请查看
    <a href="https://github.com/seajs/spm/">spm 项目</a>。
  </p>


</div>

<script src="../../build/sea.js" data-main="../../docs/assets/init"></script>

</body>
</html>
