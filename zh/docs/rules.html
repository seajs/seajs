<!doctype html>
<html>
<head>
<meta http-equiv="pragma" content="no-cache"/>
<meta charset="utf-8"/>
<title>规则 - Sea.js 手册与文档</title>
<link rel="stylesheet" href="../../docs/assets/api.css"/>
</head>
<body>
<div id="container">

  <header>
    <h1>Sea.js 手册与文档</h1>
    <div id="gtoc">
      <p><a href="../">首页</a> | <a href="index.html">索引</a></p>
    </div>
    <hr/>
  </header>

  <div id="toc">
    <h2 id="table_of_Contents">目录</h2>

    <ul>
      <li><a href="#rules">规则</a>
        <ol>
          <li><a href="#spell-it-right">正确拼写</a></li>
		  <li><a href="#leave-it-alone">自由它</a></li>
          <li><a href="#use-string-literals">使用字符串字面量</a></li>
        </ol>
      </li>
      <li><a href="#note-dynamic-deps">动态依赖小记</a></li>
    </ul>
    <hr/>
  </div>


  <h2 id="rules">规则</h2>

  <p>
    为了让静态分析正常工作，您在使用 <code>require</code> 函数时需要遵循一些简单的规则：
  </p>


  <h3 id="spell-it-right">1. 正确拼写</h3>

  <p>
    在封装代码中，第一个参数 <em>必须</em> 叫做“<code>require</code>”。
  </p>

<pre>
// 错误！
define(function(req) {
  // ...
});

// 正确！
define(function(require) {
  // ...
});
</pre>


  <h3 id="leave-it-alone">2. 自由它</h3>

  <p>
    不要重命名 <code>require</code> 函数，或在任何作用域中赋任何值给 <code>require</code> 变量。
  </p>

<pre>
// 错误 - Renaming "require"!
var req = require, mod = req("./mod");

// 错误 - Redefining "require"!
require = function() {};

// 错误 - Redefining "require" as a function parameter!
function F(require) {}

// 错误 - Redefining "require" in a nested scope!
function F() {
  var require = function() {};
}
</pre>


  <h3 id="use-string-literals">3. 使用字符串字面量</h3>

  <p>
    <code>require</code> 的参数值 <em>必须</em> 是一个字符串字面量。
  </p>

<pre>
// 错误!
require(myModule);

// 错误!
require("my-" + "module");

// 错误!
require("MY-MODULE".toLowerCase());

// 正确!
require("my-module");
</pre>

  <p>
    我向你保证，虽然要遵循这些规则，您一样可以创造大型、复杂的应用。
    把 <code>require</code> 看做语言层面的表达式，而非函数，您就释然啦。
  </p>


  <h2 id="note-dynamic-deps">动态依赖小记</h2>

  <p>
    有时候开发者希望可以有条件地使用 <code>require</code>：
  </p>

<pre>
if (todayIsWeekend)
  require("play");
else
  require("work");
</pre>

  <p>
    请牢记，从静态分析的视角来看，这个模块同时依赖“play”和“work”两个模块。装载器会试图两个都获取。
  </p>

  <p>
    在这种情况下，您可以使用 <code>require.async</code> 来有条件地异步加载模块。
  </p>


  <hr/>

  <p>
    本页派生自
    <a href="http://www.flyscript.org/docs-static-analysis">FlyScript 的文档</a>。
    感谢 Kevin H. Smith。
  </p>
  
</div>

<script src="../../build/sea.js" data-main="../../docs/assets/init"></script>

</body>
</html>
